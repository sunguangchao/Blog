总线的宽度决定了处理器一次可以从寄存器或者内存中获取到少个bit，同时也决定了处理器的最大寻址空间。
在Java中哪些组件需要使用内存？
------------------

* Java堆
    * Java堆中内存空间的管理由JVM来控制，对象创建由Java应用程序控制，但是对象所占的空间释放由管理堆内存的垃圾收集器来完成
* 线程
    * 每个线程创建时JVM都会为它创建一个堆栈，堆栈的大小根据不同的JVM实现而不同，通常在256~756KB之间
* 类和类加载器
* NIO
* JNI

JVM内存结构
-----------
Java运行时数据分为6种：
* PC寄存器数据
    * 用于保存当前正常执行程序的内存地址
* Java栈
    * Java栈总是和线程关联在一起，每当创建一个线程时，JVM就会为这个线程创建一个对应的Java栈，在这个栈种又会包含多个栈帧(Frames)，这些栈帧是与每个方法相关联的，每运行一个方法就创建一个栈帧。
* 堆
* 方法区
* 运行时常量
* 本地方法栈

JVM内存分配策略
操作系统中内存分配策略为三种：静态内存分配、栈内存分配、堆内存分配

* 静态内存分配是指在程序编译时就能确定每个数据在运行时的存储空间需求。  
* 栈式内存分配也称为动态存储分配，按照先进后出的原则进行分配

Java中内存分配详解
当创建一个线程，JVM就会为这个线程创建一个新的Java栈，一个线程的方法的调用和返回对应于这个Java栈的压栈和出栈。当线程激活一个Java方法时，JVM就会在线程的Java堆栈里新压入一个帧，这个帧自然成了当前帧。在此方法执行期间，这个帧用来保存参数、局部变量、中间计算过程和其他数据。

每个Java应用都对应一个JVM实例，每个实例唯一对应一个堆。在建立对象的过程中会在两个地方分配内存：在堆中分配的内存实际上是建立这个对象，而在堆栈中分配的内存只是一个指向这个堆对象的指针（引用）。

堆是由垃圾回收来负责的，堆的优势是可以动态分配内存的大小。

JVM回收策略
----------
主要分为静态内存分配和回收、动态内存分配和回收。

垃圾处理器的任务有两个：
* 正确地检测出垃圾对象
* 释放垃圾对象占用的内存空间

JVM在做垃圾回收时会检查堆中的对象是否都会被`根对象`直接或间接引用，能够被引用的对象就是活动对象，否则就是可以被垃圾回收器回收。

下面介绍在hotspot中使用的基于分代的垃圾收集方式  
设计思路：把对象按照寿命长短来分组，分为年轻代和年老代，新创建的对象被分在年轻代，如果对象经过几次回收后仍然存活，那么再把这个对象划分到年老代。年老代的收集频度不像年轻代那么频繁，这样就减少了每次垃圾收集时所要扫描的对象的数量，从而提高了垃圾回收效率。

Hotspot提供了三类垃圾收集的算法：

* Serial Collector(待补充)
* Parallel Collector
* CMS Collector

内存问题分析
-------------
GC的日志输出如下参数：
* -verbose:gc,以辅助输出一些详细的CG信息
* -XX:+PrintGCDetails,输出CG的详细信息
* -XX:+PrintGCApplicationStoppedTime,输出GC造成应用程序暂停的时间
* -XX:+PrintGCDateStamps,GC发生的时间信息
* -XX:+PrintHeapAtGC,在GC前后输出堆中各个区域的大小
* -Xloggc:[file],将GC的信息输出到单独文件中

GC的日志可以抽象成下列形式：
```
[GC[<collector>:<starting occupancy> -> <ending occupancy1>(total size1),<pause time1> secs] <starting occupancy2> -> <ending occupancy2>(total size2), <pause time2> secs]
```
其中说明如下：
* `<collector>`GC表示收集器的名称。
* `<starting occupancy1>`表示Yound区在GC前占用的内存
* `<ending occupancy1>`表示Yound区在GC后占用的内存
* `<pause time1>`表示Young区局部收集时JVM暂停处理的时间
* `<starting occupancy2>`表示JVM Heap在GC前占用的内存
* `<ending occupancy2>`表示JVM Heap在GC后占用的内存
* `<pause time2>`表示在GC过程中JVM暂停处理的总时间

如果随着时间的延长`<ending occupancy2>`的值一直在增长，而且FullGC很频繁，那很可能就是内存泄漏了。

实例分析
下面作者分析了三个有关内存泄漏的实例，自己读了一遍，发现印象不深，可能要有一些经验之后才有体会吧
