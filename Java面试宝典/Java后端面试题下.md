内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？
============
一个内部类对象可以引用创建它的外部类对象的成员，包括私有成员。


数据类型之间的转换
============
- 如何将字符串转换为基本数据类型：
- 如何将基本数据类型转换为字符串：

- 调用基本数据类型对应的包装类中的方法parseXXX(String)或vlaueOf(String)即可返回相应基本类型；
- 一种方法是将基本数据类型与空字符串("")连接(+)即可获得其所对应的字符串；另一种方法是调用String 类中的valueOf()方法返回相应字符串。

如何实现字符串的反转及替换
===========
```java
	public static String reverse(String str) {
		if (str == null || str.length() <= 1) {
			return str;
		}
		return reverse(str.substring(1)) + str.charAt(0);
	}
```

try{}里有一个return语句，那么紧跟在这个try后的finally{}里的代码会不会执行，什么时候被执行，在return前还是后？
===============
会执行，在方法返回调用者前执行。
注意：在finally中改变返回值的做法是不好的，因为如果存在finally代码块，try中的return语句不会立马返回调用者，而是记录下返回值待finally代码块执行完毕之后再向调用者返回其值，然后如果在finally中修改了返回值，就会返回修改后的值。显然，在finally中返回或者修改返回值会对程序造成很大的困扰，C#中直接用编译错误的方式来阻止程序员干这种龌龊的事情，Java中也可以通过提升编译器的语法检查级别来产生警告或错误，Eclipse中可以在如图所示的地方进行设置，强烈建议将此项设置为编译错误。

列出一些常见的运行时异常
========
- ArithmeticException(算数异常)
- ClassCastException(类转换异常)
- IllegalArgumentException(非法参数异常)
- IndexOutOfBoundsException(下标越界异常)
- NullPointerException(空指针异常)
- SecurityException(安全异常)

简述ArrayList、Vector、LinkedList的存储性能和特性
================
答：ArrayList 和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector中的方法由于添加了synchronized修饰，因此Vector是线程安全的容器，但性能上较ArrayList差，因此已经是Java中的遗留容器。LinkedList使用双向链表实现存储（将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号索引的线性结构，这种链式存储方式与数组的连续存储方式相比，内存的利用率更高），按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。Vector属于遗留容器（Java早期的版本中提供的容器，除此之外，Hashtable、Dictionary、BitSet、Stack、Properties都是遗留容器），已经不推荐使用，但是由于ArrayList和LinkedListed都是非线程安全的，如果遇到多个线程操作同一个容器的场景，则可以通过工具类Collections中的synchronizedList方法将其转换成线程安全的容器后再使用（这是对装饰模式的应用，将已有对象传入另一个类的构造器中创建新的对象来增强实现）。

Java中如何实现序列化，有什么意义？
=======
序列化就是一种用来处理流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可以将流化后的对象传输于网络之间。
序列化是为了解决对象流读写操作时可能引发的问题（如果不进行序列化可能会存在数据乱序的问题）。
要实现序列化，需要让一个类实现Serializable接口，该接口是一个标识性接口，标注该类对象是可被序列化的，然后使用一个输出流来构造一个对象输出流并通过writeObject(Object)方法就可以将实现对象写出（即保存其状态）；如果需要反序列化则可以用一个输入流建立对象输入流，然后通过readObject方法从流中读取对象。序列化除了能够实现对象的持久化之外，还能够用于对象的深度克隆