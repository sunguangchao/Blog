内部类的作用
==============
使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口）的实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。
接口只是解决了部分问题，而内部类使得多重继承的解决方案变得完整。

```java
OuterClass.InnerClass innerClass = outerClass.new InnerClass();
```

成员内部类：
-----------
成员内部类是最普通的内部类，它可以无限制的访问外围类的所有成员属性和方法。

注意：

1. 成员内部类中不能存在任何static的变量和方法；
2. 成员内部类是依附于外围类的，所以只有先创建外围类才能够创建内部类。


reference:
* [详解内部类](http://www.cnblogs.com/chenssy/p/3388487.html)

类加载过程
============
类加载机制：  
JVM将`类描述数据`从.class文件中加载到内存，并对数据进行`验证、准备、解析`和初始化，最终形成被JVM直接使用的Java类型。

类加载器
-------
类加载器的主要任务是类加载过程中的加载操作：
根据一个类的全限定名读取该类的二进制字节流到JVM内部，然后转换为一个对应的`java.lang.Class`对象实例。

双亲委派过程：
当一个类加载器收到类加载任务时，立即将任务委派给它的父类加载器去执行，直至委派给顶层的启动类加载器为止。如果父类加载器无法加载委派给它的类时，将类加载任务退回给它的下一级加载器去执行；

双亲委派模型可以保证全限定名指定的类，只被加载一次

Java虚拟机的特性
============
Java语言的一个非常重要的特点就是与平台的无关性。而使用Java虚拟机是实现这一特点的关键。一般的高级语言如果要在不同的平台上运行，至少需要编译成不同的目标代码。而引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用模式使Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编程程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解析成具体平台上的机器指令执行。

进程和线程的区别
=========
简而言之,一个程序至少有一个进程,一个进程至少有一个线程。

线程的划分尺度小于进程，使得多线程程序的并发性高。

另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。

线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。

从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。

进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.

线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.

一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行.

进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。

Java中==和equals的区别，equals和hashCode的区别
========
* [Java中==和equals的区别，equals和hashCode的区别](https://blog.csdn.net/tiantiandjava/article/details/46988461)

并发编程
====
* [并发编程](http://www.jackywang.tech/AndroidInterview-Q-A/chinese/java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E7%8C%8E%E8%B1%B9.html)

接口与抽象类的区别
========
1. 默认的方法实现
   * 抽象类可以有默认的方法实现完全是抽象的。接口根本不存在方法的实现
2. 实现 
  * 子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。
  * 子类使用关键字implements来实现接口。它需要提供接口中所有声明的方法的实现
3. 构造器
   * 抽象类可以有构造器
   * 接口不能有构造器
4. 与正常Java类的区别
   * 除了你不能实例化抽象类之外，它和普通Java类没有任何区; 接口是完全不同的类型
5. 访问修饰符
   * 抽象方法可以有public、protected和default这些修饰符; 接口方法默认修饰符是public。你不可以使用其它修饰符。
6. main方法
   * 抽象方法可以有main方法并且我们可以运行它
   * 接口没有main方法，因此我们不能运行它。
7. 多继承
   * 抽象类在java语言中所表示的是一种继承关系，一个子类只能存在一个父类，但是可以存在多个接口。
8. 速度
   * 它比接口速度要快
   * 接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。
9. 添加新方法
   * 如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。
   * 如果你往接口中添加方法，那么你必须改变实现该接口的类。

泛型中extends和super的区别
===========
* [泛型中extends和super的区别](https://itimetraveler.github.io/2016/12/27/%E3%80%90Java%E3%80%91%E6%B3%9B%E5%9E%8B%E4%B8%AD%20extends%20%E5%92%8C%20super%20%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F/)

volatile和synchronized的区别
==============
其实这个区别的比较是不太合适的

volatile和synchronized四个不同点： 

1. 粒度不同，前者针对变量 ，后者锁对象和类 
2. syn阻塞，volatile线程不阻塞 
3. syn保证三大特性，volatile不保证原子性 
4. syn编译器优化，volatile不优化 


volatile具备两种特性： 

1. 保证此变量对所有线程的可见性，指一条线程修改了这个变量的值，新值对于其他线程来说是可见的，但并不是多线程安全的。 
2. 禁止指令重排序优化。 

volatile如何保证内存可见性: 
1. 当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存。 
2. 当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。