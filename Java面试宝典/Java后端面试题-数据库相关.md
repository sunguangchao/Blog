三个范式：
=========
满足第三范式，就一定满足第二范式，满足第二范式，就一定满足第一范式。
* 第一范式：字段是最小的单元不可再分
* 第二范式：满足第一范式，表中的字段必须完全依赖于全部主键而非部分主键
    * 其他字段组成的这行记录和主键表示的是同一个东西，而主键是唯一的，它们只需要依赖于主键，也就成了唯一的。
* 第三范式：满足第二范式，非主键外的所有字段必须互补依赖
    * 数据只在一个地方存储，不重复出现在多张表中，可以认为就是消除传递依赖

说出一些数据库优化方面的经验
===========
1. 用PrepareStatement一般来说比Statement性能高：一个sql发给服务器去执行，涉及步骤：语法检查、语义分析，编译，缓存
2. 有外键约束会影响插入和删除性能，如果程序能够保证数据的完整性，那在设计数据库时就去掉外键。

union与union all有什么不同？
==========
UNION在进行表链接后会筛选掉重复的数据，所以在表链接后会对所产生的结果集进行排序运算，删除重复的记录后再返回结果。
而UNION ALL只是简单的将两个结果合并后就返回
从效率上来说，UNION ALL要比UNION块很多，所以，如果可以确认合并的两个结果集中不包含重复数据的话，那么就使用UNION ALL。

用一条SQL语句查询出每门课都大于80分的学生姓名。
====================
```sql
select distinct name from score where name not in (select distinct name from score where socre <= 80);
```

Class.forName的作用？为什么要用？
==================
按参数中指定的字符串形式的类名去搜索并加载相应的类，如果字节码已经被加载过，返回该字节码的Class实例对象，否则，按类加载器的委托机制去搜索和加载该类，如果所有的类加载器都无法加载到该类，则抛出ClassNotFoundException。加载完这个Class字节码后，接着就可以使用Class字节码的newInstance方法去创建该类的实例对象了。

有时候，我们程序中所有使用的具体类名在设计时无法确定，只有程序运行时才能确定，这时候就需要使用Class.forName去动态加载该类，这个类名通常是在配置文件中配置的，例如，spring的ioc中每次依赖注入的具体类中就是这样配置的，jdbc的驱动类名通常也是通过配置文件来配置的，以便在产品交付使用后不同修改源程序就可以更改驱动类名。

用JDBC查询学生成绩单，把主要代码写出来
============

说出数据库连接池的工作机制是什么。
================