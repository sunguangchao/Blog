CountDownLatch是一种灵活的闭锁实现，闭锁状态包括一个计数器，该计数器被初始化为一个正数，表示需要等待的事件数量。countDown方法递减计数器，表示由一个事件已经发生了。如果计数器的值为非零，那么await会一直阻塞到计数器为零，或者等待中的线程中断，或者等待超时。

计时测试中使用CountDownLatch来启动和停止线程

```java
public class TestHarness {
    public long timeTasks(int nThreads, final Runnable task)throws InterruptedException{
        final CountDownLatch startGate = new CountDownLatch(1);
        final CountDownLatch endGate = new CountDownLatch(nThreads);

        for (int i=0; i < nThreads; i++){
            Thread t = new Thread(){
                @Override
                public void run(){
                    try {
                        startGate.await();
                        try {
                            task.run();
                        }finally {
                            endGate.countDown();
                        }
                    }catch (InterruptedException ignored){}
                }
            };
            t.start();
        }
        long start = System.nanoTime();
        startGate.countDown();
      	endGate.await();
        long end = System.nanoTime();
        return end- start;

    }
}
```

信号量
---------

计数信号量(Counting Semaphore)用来控制同时访问某个特定资源的操作数量，或者同时执行某个操作的数量。

Semaphore中管理者一组虚拟的许可(permit)，许可的初始数量可通过构造函数来指定，在执行操作时可以首先获得许可，并在使用以后释放许可，那么acquire将阻塞到直到有许可。

应用：把该容器设置为有界阻塞容器。将信号量的计数值初始化为容器容量的最大值。

```java
public class BoundedHashSet<T> {
    private final Set<T> set;
    private final Semaphore sem;

  	//构造函数，设置容器的容量bound
    public BoundedHashSet(int bound){
        this.set = Collections.synchronizedSet(new HashSet<T>());
        sem = new Semaphore(bound);
    }

    public boolean add(T o) throws InterruptedException{
        sem.acquire();//获得许可
        boolean wasAdded = false;
        try {
            wasAdded = set.add(o);
            return wasAdded;
        }finally {
          	//如果没有增加，释放许可
            if (!wasAdded)
                sem.release();
        }
    }
    public boolean remove(Object o){
        boolean wasRemoved = set.remove(o);
      	//如果移除元素，那么释放许可
        if (wasRemoved)
            sem.release();
        return wasRemoved;
    }
}
```
栅栏

栅栏(Barrier)类似于闭锁，他能阻塞一组线程直到某个事件发生。栅栏与闭锁的区别在于，所有线程必须同时到达栅栏，才能继续执行。闭锁用于等待**事件**。而栅栏用于等待其他线程。

