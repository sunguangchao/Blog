Garbage Collection

引用计数法
----------
给对象添加一个引用计数器，每当一个地方引用它时，计数器就加一；当引用失效时，计数器就减一。

可达性分析算法
---------
Reachability Analysis：同过一系列的称为"GC Roots"的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，可以被判定为可回收的对象。

可作为`GC Roots`的对象

* 虚拟机栈（栈帧的本地变量表）中引用的对象
* 方法区中静态属性引用的对象
* 方法区中常量引用的对象
* 本地方法栈中JNI（即Native方法）引用的对象

再谈引用
-----------
引用的四种分类
* 强引用就是类似于`Object obj = new Object()`的这类引用，只要强引用还在，垃圾收集器就永远不会回收掉被引用的对象
* 软引用用来描述一些有用但并非必须的对象，在内存发生溢出异常之前，会回收掉这些对象（第二次回收），如果这次回收还没有足够的内存，才会抛出内存异常。SoftReference类
* 弱引用也是用来描述有用但并非必须的对象，但它比软引用更弱，被弱引用关联的对象只能生存至下一次回收之前，无论内存是否足够。WeakReference类
* 虚引用是最弱的一种引用，无法对生存时间造成影响，也不能通过虚引用来取得一个对象实例。其目的就是能在这个对象回收时受到一个系统通知。PhantomReference。

即使在可达性算法中不可达的对象，也要经过两次标记过程才能真正宣告死亡，而在这期间对象可以拯救自己。具体见P66

回收方法区
----------
永久代的垃圾收集主要分两部分：废弃常量和无用的类

`无用的类`的判定：
* 该类所有的实例都已近被回收，也就是说Java堆中不存在该类的任何实例
* 加载该类的ClassLoader已经被回收
* 该类对象的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

垃圾收集算法
========
标记-清除算法
----------
Mark-Sweep分为标记和清除两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。
不足之处：效率低；并且在回收之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后再程序运行过程中需要分配较大对象时，无法找到足够的连续内幕内存而不得不提前出发另一次CG。

复制算法
---------
新生代中使用

将内存分为一块较大的Eden和两块较小的Survivor，比例为8:1:1。每次回收使用Eden和一块Survivor，当回收时，将Eden和Survivor中还存活的对象一次性地复制到另一块Survivor上，最后清理掉Eden和刚才用过的Survivor。

标记-整理算法
----------
老年代主要使用这种算法
思想：让所有可存活的对象向一端移动，然后直接清理掉边界以外的内存


HotSpot的算法实现
==============
P72

垃圾收集器
=========
![](http://o90jubpdi.bkt.clouddn.com/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.jpg)
连线代表可以搭配使用

Serial收集器
-----------
进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束。也叫`Stop the World`

Serial/Serial Old搭配使用： 新生代采用复制算法，暂停所有用户线程；老年代采用标记-整理算法，也暂停所有用户进程。

Serial收集器是虚拟机运行在Client模式下的默认新生代收集器。好处是`简单高效`

ParNew
---------
Serial收集器的多线程版本。运行在Server模式下的虚拟机首选的新生代收集器。除了Serial收集器之外，目前只有他能与CMS收集器配合工作。

并发和并行的区别
* 并行(Parallel)：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态
* 并发(Concurrent)：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行于另一个CPU上

Parallel Scavenge
-----------
Parallel Scavenge也是一个新生代收集器，同样使用复制算法。
它的目标在于达到一个可控制的吞吐量(Throughput)。所谓`吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）`。

高吞吐量可以高效地利用CPU时间，尽快完成程序运算任务，主要适合在后台运算而不需要太多交互的任务。

Serial Old
---------
Serial收集器的老年代版本，单线程收集器，使用`标记-整理`算法，给Client模式下的虚拟机使用。
用途：
* 在JDk1.5之前与Parallel Scavenge收集器搭配使用
* 作为CMS收集器的后备预案，在并发收集发生`Concurrent Mode Failure`时使用。

Parallel Old
---------------
Parallel Scavenge的老年代版本，使用多线程和`标记-整理`算法
在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。


CMS
----
Concurrent Mark Sweep收集器是一种以获取最短回收停顿时间为目标的收集器。采用`标记-清除`算法。
过程
* 初始标记(CMS initial mark)
    * 标记GC Roots能直接关联到的对象
* 并发标记(CMS concurrent mark)
    * 进行GC Roots Tracing
* 重新标记(CMS remark)
* 并发清除(CMS concurrent sweep)

初始标记和重新标记仍需要`Stop the world`。但重新标记可以并行执行。

并发标记和并发清除阶段用户线程和垃圾收集线程可以一起并发执行。总的来的说，CMS是并发的。

缺点：
* 对CPU资源非常敏感，并发阶段，占用一部分线程(CPU资源)而导致程序变慢。
* 无法处理浮动垃圾(Floating Garbage)，可能出现`Concurrent Mode Failure`失败而导致另一次Full GC的产生。
* 基于`标记-清除`算法，会有大量空间碎片产生，将会给大对象分配带来麻烦。

G1收集器
---------
特点：
* 并行与并发
* 分代收集
* 空间整合：因为采用标记-整理算法，不会产生内存空间碎片
* 可预测的停顿

将整个Java堆划分成多个大小相等的独立区域(Region)。G1跟踪各个Region里面的垃圾堆积的价值大小，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值大的Region。

过程：
* 初始标记(Initial Marking)
* 并发标记(Concurrent Marking)
* 最终标记(Final Marking)
* 筛选回收(Live Data Counting and Evacaution)


内存分配与回收策略
-----------
多数情况下，对象在新生代Eden区分配。到Eden区没有足够空间进行分配时，将触发一次Minor GC

大对象是指需要大量连续内存空间的Java对象，典型的就是很长的字符串和数组。大对象直接进入老年代。

长期存活的对象进入老年代：P95
年龄阈值默认为15，可以通过`-XX:MaxTenuringThreshold`设置

动态对象年龄判定：如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，大于等于该年龄的对象就可以直接进入老年代。
