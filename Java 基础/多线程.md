什么是线程？

一个单独的线程执行一个任务的过程

--------------------------------------

```
public interface Runnable
{
  void run();
}
```
1.通过接口实现下面的类
```
class MyRunnable implements Runnable
{
  public void run()
  {
    task code
  }
}
```
2.创建一个类对象
```
Runnable r = new MyRunnable();
```
3.由Runnable创建一个Thread对象：
```
Thread t = new Thread(r);
```
4.启动线程
```
t.start()
```
--------------------

中断线程
=======
线程中的run方法执行完毕，并由执行return语句返回时，或者出现了方法中未能捕获的异常，线程将会终止。

想知道线程的中断状态是否被置位：
```
while(!Thread.currentThread().isInterrupted() && more work to do){
  do more work
}
```

java.lang.Thread
---------
* void interrupt()
  * 向线程发送中断请求。线程的中断状态被置为true。如果目前线程被一个sleep调用阻塞，那么，InterruptedException异常将被抛出
* static boolean interrupted()
  * 测试当前线程是否被中断。这是一个静态方法。这一调用将会把当前线程的中断状态重置为false
* boolean isInterrupted()
  * 测试线程是否被终止。不像静态的中断方法，这一调用不会改变线程的中断状态
* static Thread currentThread()
  * 返回代表当前执行线程的Thread对象

线程状态
==========
线程有六种状态：New, Runnable, Blocked, Waiting, Timed waiting(计时等待), Terminated(被终止)

一旦调用start方法，线程便处于Runnable状态。一个可运行的线程不一定处于运行状态，这取决于操作系统给线程提供的运行时间。

被阻塞线程和等待线程
-------
* 当一个线程试图获取一个内部的对象锁，而该锁被其他线程持有，则该线程进入阻塞状态。当其他线程释放该锁，并且线程调度器允许该线程持有该锁的时候，该线程变为非阻塞状态。
* 当线程等待另一个线程通知调度器一个条件时，它自己进入等待状态。

线程属性
=========
关于线程的优先级：默认情况下，一个线程继承它的父线程的优先级，可以用setPriority方法提高或降低任何一个线程的优先级。

signalAll方法不会立即激活一个等待线程。它仅仅解除等待线程的阻塞，以便这些线程可以在当前线程退出同步方法之后，通过竞争实现对对象的访问。
signal随机解除等待集中某个线程的阻塞状态。

```java
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * Created by 11981 on 2017/3/7.
 */
public class Bank {
    private final double[] accounts;
    private Lock bankLock;
    private Condition sufficientFunds;

    //Constructs the bank
    public Bank(int n, double initialBalance)
    {
        accounts = new double[n];
        for (int i = 0;i < accounts.length; i++)
            accounts[i] = initialBalance;
        //构建一个可以被用来保护临界区的可重入锁
        bankLock = new ReentrantLock();
        //使用条件对象来管理锁
        sufficientFunds = bankLock.newCondition();
    }

    public void transfer(int from, int to, double amount) throws InterruptedException
    {
        bankLock.lock();
        try{
            while (accounts[from] < amount)
                sufficientFunds.await();//将该线程放到等待集中
            System.out.print(Thread.currentThread());
            accounts[from] -= amount;
            System.out.printf("%10.2f from %d to %d", amount, from, to);
            accounts[to] += amount;
            System.out.printf("Total balance: %10.2f%n",getTotalBalance());
            sufficientFunds.signalAll();//解除等待集中所有线程的阻塞状态
        }
        finally {
            bankLock.unlock();
        }
    }

    public double getTotalBalance(){
        bankLock.lock();
        try{
            double sum = 0;

            for (double a : accounts)
                sum += a;
            return sum;
        }
        finally {
            bankLock.unlock();
        }
    }

    public int size(){
        return accounts.length;
    }

}
```
总结：

* 锁用来保护代码片段，任何时刻只能有一个线程执行被保护的代码
* 锁可以管理试图进入被保护代码段的线程
* 锁可以拥有一个或多个相关的条件对象
* 每个条件对象管理那些已经进入被保护的代码段但还不能运行的线程


synchronized
----------
使用synchronized关键字时，每一个对象有一个内部锁，并且该锁有一个内部条件。由锁来管理那些试图进入synchronized方法的线程，由条件来管理那些调用wait的线程。

内部锁和条件的局限性：

* 不能中断一个正在试图获得锁的线程
* 试图获得锁时不能设定超时
* 每个锁仅有一个单一条件，可能是不够的


Volatile域
---------
* 多处理的计算机能够暂时在寄存器或本地内存缓存区中保存内存中的值。结果是，运行在不同处理器上的线程可能在同一个内存位置取到不同的值。
* 编译器可以改变指令的执行的顺序以使吞吐量最大化。这种顺序上的变化不会改变代码语义，但是编译器假定内存的值仅仅在代码中有显式的修改指令时才会改变。然而，内存的值可以被另一个线程改变。

volatile关键字为实力域的同步访问提供了一种免锁机制。如果声明一个域为volatile，那么编译器和虚拟机就知道该域可能被另一个线程并发更新的。

线程局部变量：  
在线程中共享变量是有风险的，有时候为了避免共享变量，使用ThreadLocal辅助类可以为各个线程提供各自的实例。

```java
public static final ThreadLocal<SimpleDateFormat> dateFormat =
  new ThreadLocal<SimpleDateFormat>()
    {
      protected SimpleDateFormat initialValue()
      {
        return new SimpleDateFormat("yyyy-MM-dd");
      }
    };
```

tryLock方法试图申请一个锁，在成功获得锁后返回true，否则，立即返回false，而且线程可以立即离开去做其他事。而且如果线程在等待获得一个锁时被中断，将抛出InterruptedException异常。

读/写锁的必要步骤
----------
构造一个ReentrantReadWriteLock对象
```
private ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();
```
抽取读锁和写锁：
```
private Lock readLock = rwl.readLock();
private Lock writeLock = rwl.writeLock();
```
对所有的获取方法加锁：
```
public double getTotalBalance(){
  readLock.lock();
  try {...}
  finally {readLock.unlock();}
}
```
对所有的方法修改方法加写锁：
```
public void transfer(...)
{
  writeLock.lock();
  try {...}
  finally {writeLock.unlock();}
}
```

如何安全地挂起线程？
```java
private volatile boolean suspendRequested = false;
private Lock suspendLock = new ReentrantLock();
private Condition suspendCondition = suspendLock.newCondition();

public void run(){
	while(...){
		...
		if (suspendRequested) {
			suspendLock.lock();
			try{while(suspendRequested) suspendCondition.await();}
		}	finally{suspendLock.unlock();}
	}
}

public void requestSuspend() {suspendRequested = true;}

public void requestResume(){
	suspendRequested  = false;
	suspendLock.lock();
	try{suspendCondition.signalAll();}
	finally{suspendLock.unlock();}
}
```

后面的主要是线程池，同步器（信号量、倒计时门栓、障栅、交换器）感觉用到的不多，没有详细看
