Java后端面试题

------------------------------------
面对对象的三个特性：封装，继承，多态
多态的好处：
* 可替换性：多态对已存在的代码具有可替换性
* 可扩充性：增加新的子类不影响已经存在的类的结构
* 接口性：多态是超类通过方法签名，向子类提供一个公共接口，由子类来完善或者重写它来实现
* 灵活性：

如何实现多态：
* 接口实现
* 继承父类重写方法
* 同一类中进行方法重载

虚拟机是如何实现多态的  
动态绑定技术(dynamic binding)，执行期间判断所引用对象的实际类型，根据实际类型调用对应的方法。


--------------------------------------
抽象类的意义：
1. 为其他子类提供一个公共的类型
2. 封装子类中重复定义的内容
3. 定义抽象方法

比较    |抽象类    |接口
-------|-----------|--------
默认方法|抽象类可以有默认的方法实现 |Java8之前，接口中不存在方法的实现
实现方式|子类使用extends关键字来继承抽象类，子类需要提供抽象类中所声明方法的实现。  |子类使用implements来实现接口，需要提供接口中所有声明的实现
构造器 |抽象类中可以有构造器  |接口中不能
和正常类区别 |抽象类不能被实例化  |接口则是完全不同的类型
访问修饰符 |抽象方法可以有public,protected和default等修饰符 |接口默认是public，不能使用其他修饰符
添加新方法 |向抽象类中添加新方法，可以提供默认的实现，因此可以不修改子类现有的代码  |如果往接口中添加新方法，则子类中需要实现该方法

-----------------------
什么是不可变对象  
不可变对象指对象一旦被创建，状态就不能被改变。任何修改都会创建一个新的对象。如String、Integer及其他包装类


Java中创建对象的几种方式
1. 采用new
2. 采用反射
3. 采用clone
4. 通过序列化机制

Object中的公共方法：
1. equals()
2. clone():obj.clone().getClass() == obj.getClass()
3. getClass()
4. notify(),notifyAll(),wait()

----------------------
Java中`==`和`equals()`的区别  
==是运算符，用于比较两个变量是否相等，基本类型域。
Object中equals()方法用于检测两个对象是否相等，判断两个对象是否具有相同的引用。  
如果a和b都是对象，则a==b是比较两个对象的引用，只有当 a 和b指向的是堆中的同一个对象才会返回 true，而 a.equals(b)是进行逻辑比较，所以通常需要重写该方法来提供逻辑一致性的比较。

equals()和hashCode()的联系
hashCode()是Object类的一个方法，返回一个哈希值。如果两个对象根据equals()方法比较相等，那么调用这两个对象中任意一个对象的hashCode()方法必须产生相同的hash值。
如果两个对象根据equals()方法比较不相等，那么产生的哈希值不一定相等（碰撞的情况下还是会相等的）

a.hashCode()有什么用?与a.equals(b)有什么关系  
hashCode()方法是相应对象整型的 hash 值。它常用于基于hash的集合类，如 Hashtable、HashMap、LinkedHashMap等等。它与equals()方法关系特别紧密。根据 Java 规范，两个使用equal()方法来判断相等的对象，必须具有相同的 hashcode。  
将对象放入到集合中时,首先判断要放入对象的hashcode是否已经在集合中存在,不存在则直接放入集合.如果hashcode相等,然后通过equal()方法判断要放入对象与集合中的任意对象是否相等:如果equal()判断不相等,直接将该元素放入集合中,否则不放入.

-------------------------------------
内部类的作用：
内部类可以用多个实例，每个实例都有自己的状态信息，并与其它外围对象的信息相互独立。在单个外围类中，可以让多个内部类以不同的方式实现同一接口，或者继承同一个类。创建内部类对象的时刻并不依赖于外部类对象的创建。内部类没有令人疑惑的`is-a`关系，它就像一个独立的实体。
内部类提供了更好的封装，除了该外围类，其他类都不能访问。

String,StringBuilder和StringBuffer区别
--------------------------------------

--------------------------------------
进程，线程之间的区别

进程是程序运行和资源分配的基本单位，一个程序至少有一个进程，一个进程至少有一个线程。进程在执行过程中拥有独立的内存单元，而多个线程共享内存资源，减少上下文切换次数，从而效率更高。同一个进程中的多个线程可以并发执行。

守护线程

程序运行完毕，jvm会等待非守护线程完成后关闭，但是jvm不会等待守护线程。守护线程最典型的的例子就是GC线程。

`多线程的上下文切换`是指CPU控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取CPU执行权的线程的过程。

创建线程的两种方式
--------------

Runnable和Callable的区别

Runnable接口中的run方法的返回值是void，它做的事只是去执行run方法中的代码；Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。`Callable+Future/FutureTask`可以获得多线程运行的结果，在等待时间太长没获取到需要的数据的情况下取消该线程的任务。


什么导致线程阻塞

方法  |说明
------|-------
sleep() |sleep() 允许 指定以毫秒为单位的一段时间作为参数，它使得线程在指定的时间内进入阻塞状态，不能得到CPU 时间，指定的时间一过，线程重新进入可执行状态。 典型地，sleep() 被用在等待某个资源就绪的情形：测试发现条件不满足后，让线程阻塞一段时间后重新测试，直到条件满足为止
suspend()和resume() |两个方法配套使用，suspend()使得线程进入阻塞状态，并且不会自动恢复，必须其对应的resume() 被调用，才能使得线程重新进入可执行状态。典型地，suspend() 和 resume() 被用在等待另一个线程产生的结果的情形：测试发现结果还没有产生后，让线程阻塞，另一个线程产生了结果后，调用 resume() 使其恢复。
yeikd() |yield() 使得线程放弃当前分得的 CPU 时间，但是不使线程阻塞，即线程仍处于可执行状态，随时可能再次分得 CPU 时间。调用 yield() 的效果等价于调度程序认为该线程已执行了足够的时间从而转到另一个线程
wait()和notify() |两个方法配套使用，wait() 使得线程进入阻塞状态，它有两种形式，一种允许 指定以毫秒为单位的一段时间作为参数，另一种没有参数，前者当对应的 notify() 被调用或者超出指定时间时线程重新进入可执行状态，后者则必须对应的 notify() 被调用.
