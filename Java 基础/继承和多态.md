继承
======
之所以叫继承是因为，子类继承了父类的属性和行为，父类有的属性和行为，子类都有。但子类可以增加子类特有的属性和行为，某些父类有的行为，子类的实现方式可能与父类也不完全一样。

使用继承一方面可以复用代码，公共的属性和行为可以放到父类中，而子类只需要关注子类特有的就可以了，另一方面，不同子类的对象可以更为方便的被统一处理。

Object
------
toString()
```java
public Stirng toString(){
  return getClass().getName() + "@" + Integer.toHexString(hashCode());
}
```
`@Override`表示重写父类的方法
说明：

* Java使用extends关键字表明继承关系，一个类最多只能有一个父类
* 子类不能直接访问父类的私有属性和方法
* 除了私有的外，子类继承了父类的其他属性和方法

super的使用与this有点像，但super和this是不同的，this引用一个对象，是实实在在存在的，可以作为函数参数，可以作为返回值，但super只是一个关键字，不能作为参数和返回值，它只是用于告诉编译器访问父类的相关变量和方法。

抽象类
---
包含一个或多个抽象方法的类本身必须被声明为抽象类。
```
abstract class Person{
    public abstract String getDescription();
}
```
抽象类不能被实例化。

protected对本包和子类可见

动态绑定
--------
对象方法的执行过程：
* 首先，编译器查看对象的声明类型和方法名。
* 接下来，编译器将查看调用方法时提供的参数类型。
* 调用的方法依赖于隐式参数的实际类型，并且在运行时实现动态绑定
* 当程序运行，并且采用动态绑定调用方法时，虚拟机一定调用与x所引用对象的实际类型最适合的那个类的方法。

强制类型转换
------
进行类型转换的唯一原因：在暂时忽视对象的实际类型之后，使用对象的全部功能。
* 只能在继承层次内进行类型转换
* 在将超类转换成子类之前，应该使用instanceof进行检查

子类对象赋值给父类引用变量，这叫向上转型，转型就是转换类型，向上转型就是转换为父类类型。

`多态，即一种类型的变量，可引用多种实际类型对象`。这样，对于变量shape，它就有两个类型，类型Shape，我们称之为shape的静态类型，类型Circle/Line/ArrowLine，我们称之为shape的动态类型。在ShapeManager的draw方法中，shapes[i].draw()调用的是其对应动态类型的draw方法，这称之为方法的动态绑定。

小结：

* 每个类有且只有一个父类，没有声明父类的其父类为Object，子类继承了父类非private的属性和方法，可以增加自己的属性和方法，可以重写父类的方法实现。
* new过程中，父类先进行初始化，可通过super调用父类相应的构造方法，没有使用super的话，调用父类的默认构造方法。
* 子类变量和方法与父类重名的情况下，可通过super强制访问父类的变量和方法。
* 子类对象可以赋值给父类引用变量，这叫`多态`，实际执行调用的是子类实现，这叫`动态绑定`。


当有多个重名函数的时候，在决定要调用哪个函数的过程中，首先是按照参数类型进行匹配的，换句话说，寻找在所有重载版本中最匹配的，然后才看变量的动态类型，进行动态绑定。
